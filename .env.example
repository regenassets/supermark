NEXTAUTH_SECRET=my-superstrong-secret
NEXTAUTH_URL=http://localhost:3000

NEXT_PUBLIC_BASE_URL=http://localhost:3000
NEXT_PUBLIC_MARKETING_URL=http://localhost:3000

# Internal API key for server-to-server communication (generate a random string for local dev)
INTERNAL_API_KEY=local-dev-internal-api-key-change-in-production

NEXT_PUBLIC_APP_BASE_HOST=localhost

# These variables are from Vercel Storage Postgres
POSTGRES_PRISMA_URL=
POSTGRES_PRISMA_URL_NON_POOLING=
# This variable is from Vercel Storage Blob
BLOB_READ_WRITE_TOKEN=

# Google client id and secret for authentication
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=

# This variable is from Resend to send emails
RESEND_API_KEY=

# This variable is from Tinybird to publish and read event data
TINYBIRD_TOKEN=

# These variables are from Vercel and used for setting up custom domains
PROJECT_ID_VERCEL=
TEAM_ID_VERCEL=
AUTH_BEARER_TOKEN=

# Upstash QStash – required for queues and background jobs
# Get your QStash Token here: https://upstash.com/docs/qstash/overall/getstarted
QSTASH_TOKEN=
QSTASH_CURRENT_SIGNING_KEY=
QSTASH_NEXT_SIGNING_KEY=

# HANKO - required for signup with passkey
# Get your HANKO keys here: https://docs.hanko.io/passkey-api/reference/credentials/list-credentials
HANKO_API_KEY=add-your-hanko-api-key
NEXT_PUBLIC_HANKO_TENANT_ID=add-your-hanko-tenent-id

# Trigger v3
TRIGGER_SECRET_KEY=
TRIGGER_API_URL=https://api.trigger.dev

# [[STORAGE]]
# Defines the storage transport to use. Available options: vercel (default) | s3
# For Cloudflare R2, use s3 mode
NEXT_PUBLIC_UPLOAD_TRANSPORT="s3"

# REQUIRED: Defines the distribution host (without protocol) to use for the storage transport
# For Vercel Blob: <BLOB_STORE_ID>.public.blob.vercel-storage.com
# For Cloudfront: <DISTRIBUTION_ID>.cloudfront.net
# For AWS S3: <BUCKET_NAME>.s3.<REGION>.amazonaws.com
# For Cloudflare R2: <BUCKET_NAME>.r2.dev (or your custom domain)
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_HOST="<BUCKET_NAME>.r2.dev"

# CLOUDFLARE R2 CONFIGURATION (Recommended for self-hosted)
# Get your R2 credentials from Cloudflare dashboard -> R2 -> Manage R2 API Tokens
# Endpoint format: https://<ACCOUNT_ID>.r2.cloudflarestorage.com
NEXT_PRIVATE_UPLOAD_ENDPOINT="https://<ACCOUNT_ID>.r2.cloudflarestorage.com"
# R2 uses "auto" region
NEXT_PRIVATE_UPLOAD_REGION="auto"
# Your R2 bucket name
NEXT_PRIVATE_UPLOAD_BUCKET="supermark-documents"
# R2 Access Key ID
NEXT_PRIVATE_UPLOAD_ACCESS_KEY_ID=""
# R2 Secret Access Key
NEXT_PRIVATE_UPLOAD_SECRET_ACCESS_KEY=""

# AWS S3 / MINIO CONFIGURATION (Alternative)
# Leave NEXT_PRIVATE_UPLOAD_ENDPOINT empty for AWS S3 (uses default endpoint)
# For MinIO, set to http://minio:9000 or your MinIO endpoint
# NEXT_PRIVATE_UPLOAD_ENDPOINT=""
# NEXT_PRIVATE_UPLOAD_REGION="us-east-1"
# NEXT_PRIVATE_UPLOAD_BUCKET="YOUR_BUCKET_NAME"
# NEXT_PRIVATE_UPLOAD_ACCESS_KEY_ID=""
# NEXT_PRIVATE_UPLOAD_SECRET_ACCESS_KEY=""

# CLOUDFRONT CONFIGURATION (Optional - for AWS S3 with CDN)
# Only needed if using Cloudfront with AWS S3
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_DOMAIN=""
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_KEY_ID=""
# Should be a PEM-encoded RSA 2048 private key
NEXT_PRIVATE_UPLOAD_DISTRIBUTION_KEY_CONTENTS=

# Encryption key for document passwords. 
NEXT_PRIVATE_DOCUMENT_PASSWORD_KEY=my-superstrong-document-secret

# [[REDIS LOCKER CONFIGURATION]]
# For bulk upload using tus.io, we use a Redis-based locker to prevent corruption of the data.
UPSTASH_REDIS_REST_LOCKER_URL=
UPSTASH_REDIS_REST_LOCKER_TOKEN=

# [[VERIFICATION]]
# Secret used to generate the checksum for the verification URL
NEXT_PRIVATE_VERIFICATION_SECRET=

# [[INCOMING WEBHOOKS]]
NEXT_PUBLIC_WEBHOOK_BASE_URL=
NEXT_PUBLIC_WEBHOOK_BASE_HOST=
